"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartAccount = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const Preverificaiton_1 = require("./utils/Preverificaiton");
const common_1 = require("@biconomy/common");
const common_2 = require("@biconomy/common");
const paymaster_1 = require("@biconomy/paymaster");
const Constants_1 = require("./utils/Constants");
// Notice: only to be used as base class for child class BiconomySmartAccount(V1)
class SmartAccount {
    constructor(_smartAccountConfig) {
        this.initCode = "0x";
        this.smartAccountConfig = _smartAccountConfig;
    }
    setEntryPointAddress(entryPointAddress) {
        this.smartAccountConfig.entryPointAddress = entryPointAddress;
    }
    validateUserOp(userOp, requiredFields) {
        for (const field of requiredFields) {
            if (!userOp[field]) {
                throw new Error(`${String(field)} is missing in the UserOp`);
            }
        }
        return true;
    }
    isProxyDefined() {
        if (!this.proxy)
            throw new Error("Proxy is undefined");
        return true;
    }
    isSignerDefined() {
        if (!this.signer)
            throw new Error("Signer is undefined");
        return true;
    }
    isProviderDefined() {
        if (!this.provider)
            throw new Error("Provider is undefined");
        return true;
    }
    async calculateUserOpGasValues(userOp) {
        var _a, _b, _c, _d, _e, _f;
        if (!this.provider)
            throw new Error("Provider is not present for making rpc calls");
        const feeData = await this.provider.getFeeData();
        userOp.maxFeePerGas = (_c = (_b = (_a = userOp.maxFeePerGas) !== null && _a !== void 0 ? _a : feeData.maxFeePerGas) !== null && _b !== void 0 ? _b : feeData.gasPrice) !== null && _c !== void 0 ? _c : (await this.provider.getGasPrice());
        userOp.maxPriorityFeePerGas =
            (_f = (_e = (_d = userOp.maxPriorityFeePerGas) !== null && _d !== void 0 ? _d : feeData.maxPriorityFeePerGas) !== null && _e !== void 0 ? _e : feeData.gasPrice) !== null && _f !== void 0 ? _f : (await this.provider.getGasPrice());
        if (userOp.initCode)
            userOp.verificationGasLimit =
                userOp.verificationGasLimit !== null || userOp.verificationGasLimit !== undefined
                    ? userOp.verificationGasLimit
                    : await this.getVerificationGasLimit(userOp.initCode);
        userOp.callGasLimit =
            userOp.callGasLimit !== null || userOp.callGasLimit !== undefined
                ? userOp.callGasLimit
                : await this.provider.estimateGas({
                    from: this.smartAccountConfig.entryPointAddress,
                    to: userOp.sender,
                    data: userOp.callData,
                });
        userOp.preVerificationGas =
            userOp.preVerificationGas !== null || userOp.preVerificationGas !== undefined ? userOp.preVerificationGas : this.getPreVerificationGas(userOp);
        return userOp;
    }
    async estimateUserOpGas(params) {
        var _a, _b, _c, _d, _e;
        let userOp = params.userOp;
        const { overrides, skipBundlerGasEstimation, paymasterServiceData } = params;
        const requiredFields = ["sender", "nonce", "initCode", "callData"];
        this.validateUserOp(userOp, requiredFields);
        let finalUserOp = userOp;
        const skipBundlerCall = skipBundlerGasEstimation !== null && skipBundlerGasEstimation !== void 0 ? skipBundlerGasEstimation : true;
        // Override gas values in userOp if provided in overrides params
        if (overrides) {
            userOp = { ...userOp, ...overrides };
        }
        common_2.Logger.log("userOp in estimation", userOp);
        if (skipBundlerCall) {
            if (this.paymaster && this.paymaster instanceof paymaster_1.BiconomyPaymaster) {
                if (!userOp.maxFeePerGas && !userOp.maxPriorityFeePerGas) {
                    throw new Error("maxFeePerGas and maxPriorityFeePerGas are required for skipBundlerCall mode");
                }
                if ((paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.mode) === paymaster_1.PaymasterMode.SPONSORED) {
                    const v1BiconomyInfo = {
                        name: "BICONOMY",
                        version: "1.0.0",
                    };
                    const smartAccountInfo = (_a = paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.smartAccountInfo) !== null && _a !== void 0 ? _a : v1BiconomyInfo;
                    paymasterServiceData.smartAccountInfo = smartAccountInfo;
                    // Making call to paymaster to get gas estimations for userOp
                    const { callGasLimit, verificationGasLimit, preVerificationGas, paymasterAndData } = await this.paymaster.getPaymasterAndData(userOp, paymasterServiceData);
                    finalUserOp.verificationGasLimit = verificationGasLimit !== null && verificationGasLimit !== void 0 ? verificationGasLimit : userOp.verificationGasLimit;
                    finalUserOp.callGasLimit = callGasLimit !== null && callGasLimit !== void 0 ? callGasLimit : userOp.callGasLimit;
                    finalUserOp.preVerificationGas = preVerificationGas !== null && preVerificationGas !== void 0 ? preVerificationGas : userOp.preVerificationGas;
                    finalUserOp.paymasterAndData = paymasterAndData !== null && paymasterAndData !== void 0 ? paymasterAndData : userOp.paymasterAndData;
                }
                else {
                    // use dummy values for gas limits as fee quote call will ignore this later.
                    finalUserOp.callGasLimit = Constants_1.DefaultGasLimit.callGasLimit;
                    finalUserOp.verificationGasLimit = Constants_1.DefaultGasLimit.verificationGasLimit;
                    finalUserOp.preVerificationGas = Constants_1.DefaultGasLimit.preVerificationGas;
                }
            }
            else {
                common_2.Logger.warn("Skipped paymaster call. If you are using paymasterAndData, generate data externally");
                finalUserOp = await this.calculateUserOpGasValues(userOp);
                finalUserOp.paymasterAndData = "0x";
            }
        }
        else {
            if (!this.bundler)
                throw new Error("Bundler is not provided");
            delete userOp.maxFeePerGas;
            delete userOp.maxPriorityFeePerGas;
            // Making call to bundler to get gas estimations for userOp
            const { callGasLimit, verificationGasLimit, preVerificationGas, maxFeePerGas, maxPriorityFeePerGas } = await this.bundler.estimateUserOpGas(userOp);
            // if neither user sent gas fee nor the bundler, estimate gas from provider
            if (!userOp.maxFeePerGas && !userOp.maxPriorityFeePerGas && (!maxFeePerGas || !maxPriorityFeePerGas)) {
                const feeData = await this.provider.getFeeData();
                finalUserOp.maxFeePerGas = (_c = (_b = feeData.maxFeePerGas) !== null && _b !== void 0 ? _b : feeData.gasPrice) !== null && _c !== void 0 ? _c : (await this.provider.getGasPrice());
                finalUserOp.maxPriorityFeePerGas = (_e = (_d = feeData.maxPriorityFeePerGas) !== null && _d !== void 0 ? _d : feeData.gasPrice) !== null && _e !== void 0 ? _e : (await this.provider.getGasPrice());
            }
            else {
                finalUserOp.maxFeePerGas = maxFeePerGas !== null && maxFeePerGas !== void 0 ? maxFeePerGas : userOp.maxFeePerGas;
                finalUserOp.maxPriorityFeePerGas = maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== void 0 ? maxPriorityFeePerGas : userOp.maxPriorityFeePerGas;
            }
            finalUserOp.verificationGasLimit = verificationGasLimit !== null && verificationGasLimit !== void 0 ? verificationGasLimit : userOp.verificationGasLimit;
            finalUserOp.callGasLimit = callGasLimit !== null && callGasLimit !== void 0 ? callGasLimit : userOp.callGasLimit;
            finalUserOp.preVerificationGas = preVerificationGas !== null && preVerificationGas !== void 0 ? preVerificationGas : userOp.preVerificationGas;
            finalUserOp.paymasterAndData = "0x";
        }
        return finalUserOp;
    }
    async isAccountDeployed(address) {
        this.isProviderDefined();
        const contractCode = await this.provider.getCode(address);
        return contractCode !== "0x";
    }
    // Would only be used if paymaster is attached
    async getPaymasterAndData(userOp) {
        if (this.paymaster) {
            const paymasterAndDataResponse = await this.paymaster.getPaymasterAndData(userOp);
            return paymasterAndDataResponse.paymasterAndData;
        }
        return "0x";
    }
    nonce() {
        this.isProxyDefined();
        return this.proxy.nonce();
    }
    async signUserOpHash(userOpHash, signer) {
        if (signer) {
            return signer.signMessage((0, utils_1.arrayify)(userOpHash));
        }
        if (this.signer) {
            return this.signer.signMessage((0, utils_1.arrayify)(userOpHash));
        }
        throw new Error("No signer provided to sign userOp");
    }
    getPreVerificationGas(userOp) {
        return (0, Preverificaiton_1.calcPreVerificationGas)(userOp);
    }
    async getVerificationGasLimit(initCode) {
        // Verification gas should be max(initGas(wallet deployment) + validateUserOp + validatePaymasterUserOp , postOp)
        const initGas = await this.estimateCreationGas(initCode);
        const validateUserOpGas = ethers_1.BigNumber.from(Preverificaiton_1.DefaultGasLimits.validatePaymasterUserOpGas + Preverificaiton_1.DefaultGasLimits.validateUserOpGas);
        const postOpGas = ethers_1.BigNumber.from(Preverificaiton_1.DefaultGasLimits.postOpGas);
        let verificationGasLimit = ethers_1.BigNumber.from(validateUserOpGas).add(initGas);
        if (ethers_1.BigNumber.from(postOpGas).gt(verificationGasLimit)) {
            verificationGasLimit = postOpGas;
        }
        return verificationGasLimit;
    }
    async getUserOpHash(userOp) {
        const userOpHash = (0, utils_1.keccak256)((0, common_1.packUserOp)(userOp, true));
        const enc = utils_1.defaultAbiCoder.encode(["bytes32", "address", "uint256"], [userOpHash, this.entryPoint.address, this.chainId]);
        return (0, utils_1.keccak256)(enc);
    }
    async estimateCreationGas(initCode) {
        if (initCode == null || initCode === "0x")
            return ethers_1.BigNumber.from("0");
        const deployerAddress = initCode.substring(0, 42);
        const deployerCallData = "0x" + initCode.substring(42);
        return this.provider.estimateGas({ to: deployerAddress, data: deployerCallData });
    }
    async signUserOp(userOp) {
        const requiredFields = [
            "sender",
            "nonce",
            "initCode",
            "callData",
            "callGasLimit",
            "verificationGasLimit",
            "preVerificationGas",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "paymasterAndData",
        ];
        this.validateUserOp(userOp, requiredFields);
        const userOpHash = await this.getUserOpHash(userOp);
        let signature = await this.signUserOpHash(userOpHash, this.signer);
        const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);
        if (![27, 28].includes(potentiallyIncorrectV)) {
            const correctV = potentiallyIncorrectV + 27;
            signature = signature.slice(0, -2) + correctV.toString(16);
        }
        if (signature.slice(0, 2) !== "0x") {
            signature = "0x" + signature;
        }
        userOp.signature = signature;
        return userOp;
    }
    /**
     *
     * @param userOp
     * @description This function call will take 'unsignedUserOp' as an input, sign it with the owner key, and send it to the bundler.
     * @returns Promise<UserOpResponse>
     */
    async sendUserOp(userOp, params) {
        common_2.Logger.log("userOp received in base account ", userOp);
        delete userOp.signature;
        const userOperation = await this.signUserOp(userOp);
        const bundlerResponse = await this.sendSignedUserOp(userOperation, params);
        return bundlerResponse;
    }
    /**
     *
     * @param userOp
     * @description This function call will take 'signedUserOp' as input and send it to the bundler
     * @returns
     */
    async sendSignedUserOp(userOp, params) {
        const requiredFields = [
            "sender",
            "nonce",
            "initCode",
            "callData",
            "callGasLimit",
            "verificationGasLimit",
            "preVerificationGas",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "paymasterAndData",
            "signature",
        ];
        this.validateUserOp(userOp, requiredFields);
        common_2.Logger.log("userOp validated");
        if (!this.bundler)
            throw new Error("Bundler is not provided");
        common_2.Logger.log("userOp being sent to the bundler", userOp);
        const bundlerResponse = await this.bundler.sendUserOp(userOp, params === null || params === void 0 ? void 0 : params.simulationType);
        return bundlerResponse;
    }
}
exports.SmartAccount = SmartAccount;
//# sourceMappingURL=SmartAccount.js.map