import { JsonRpcProvider } from "@ethersproject/providers";
import { BigNumber, Signer, BytesLike } from "ethers";
import { ISmartAccount } from "./interfaces/ISmartAccount";
import { UserOperation, ChainId } from "@biconomy/core-types";
import { IBundler, UserOpResponse } from "@biconomy/bundler";
import { IPaymaster } from "@biconomy/paymaster";
import { IEntryPoint } from "@account-abstraction/contracts";
import { SmartAccountConfig, SendUserOpDto, EstimateUserOpGasParams } from "./utils/Types";
export declare abstract class SmartAccount implements ISmartAccount {
    bundler: IBundler;
    paymaster: IPaymaster;
    initCode: string;
    proxy: any;
    owner: string;
    provider: JsonRpcProvider;
    entryPoint: IEntryPoint;
    chainId: ChainId;
    signer: Signer;
    smartAccountConfig: SmartAccountConfig;
    constructor(_smartAccountConfig: SmartAccountConfig);
    setEntryPointAddress(entryPointAddress: string): void;
    private validateUserOp;
    isProxyDefined(): boolean;
    isSignerDefined(): boolean;
    isProviderDefined(): boolean;
    abstract getDummySignature(): string;
    calculateUserOpGasValues(userOp: Partial<UserOperation>): Promise<Partial<UserOperation>>;
    estimateUserOpGas(params: EstimateUserOpGasParams): Promise<Partial<UserOperation>>;
    isAccountDeployed(address: string): Promise<boolean>;
    getPaymasterAndData(userOp: Partial<UserOperation>): Promise<string>;
    nonce(): Promise<BigNumber>;
    signUserOpHash(userOpHash: string, signer?: Signer): Promise<string>;
    getPreVerificationGas(userOp: Partial<UserOperation>): BigNumber;
    getVerificationGasLimit(initCode: BytesLike): Promise<BigNumber>;
    getUserOpHash(userOp: Partial<UserOperation>): Promise<string>;
    abstract getSmartAccountAddress(_accountIndex: number): Promise<string>;
    estimateCreationGas(initCode: string): Promise<BigNumber>;
    signUserOp(userOp: Partial<UserOperation>): Promise<UserOperation>;
    /**
     *
     * @param userOp
     * @description This function call will take 'unsignedUserOp' as an input, sign it with the owner key, and send it to the bundler.
     * @returns Promise<UserOpResponse>
     */
    sendUserOp(userOp: Partial<UserOperation>, params?: SendUserOpDto): Promise<UserOpResponse>;
    /**
     *
     * @param userOp
     * @description This function call will take 'signedUserOp' as input and send it to the bundler
     * @returns
     */
    sendSignedUserOp(userOp: UserOperation, params?: SendUserOpDto): Promise<UserOpResponse>;
}
