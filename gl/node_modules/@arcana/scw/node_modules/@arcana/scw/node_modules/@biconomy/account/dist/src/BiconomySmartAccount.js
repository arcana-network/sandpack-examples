"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BiconomySmartAccount = void 0;
const providers_1 = require("@ethersproject/providers");
const ethers_1 = require("ethers");
const SmartAccount_1 = require("./SmartAccount");
const common_1 = require("@biconomy/common");
const core_types_1 = require("@biconomy/core-types");
const node_client_1 = __importDefault(require("@biconomy/node-client"));
const paymaster_1 = require("@biconomy/paymaster");
const modules_1 = require("@biconomy/modules");
const Constants_1 = require("./utils/Constants");
class BiconomySmartAccount extends SmartAccount_1.SmartAccount {
    constructor(biconomySmartAccountConfig) {
        const { signer, rpcUrl, entryPointAddress, bundler, paymaster, chainId, nodeClientUrl } = biconomySmartAccountConfig;
        const _entryPointAddress = entryPointAddress !== null && entryPointAddress !== void 0 ? entryPointAddress : Constants_1.DEFAULT_ENTRYPOINT_ADDRESS;
        super({
            bundler,
            entryPointAddress: _entryPointAddress,
        });
        this.biconomySmartAccountConfig = biconomySmartAccountConfig;
        const _rpcUrl = rpcUrl !== null && rpcUrl !== void 0 ? rpcUrl : common_1.RPC_PROVIDER_URLS[chainId];
        if (!_rpcUrl) {
            throw new Error(`Chain Id ${chainId} is not supported. Please refer to the following link for supported chains list https://docs.biconomy.io/build-with-biconomy-sdk/gasless-transactions#supported-chains`);
        }
        this.provider = new providers_1.JsonRpcProvider(_rpcUrl);
        this.nodeClient = new node_client_1.default({ txServiceUrl: nodeClientUrl !== null && nodeClientUrl !== void 0 ? nodeClientUrl : common_1.NODE_CLIENT_URL });
        this.signer = signer;
        if (paymaster) {
            this.paymaster = paymaster;
        }
        if (bundler)
            this.bundler = bundler;
    }
    /**
     * @description This function will initialise BiconomyAccount class state
     * @returns Promise<BiconomyAccount>
     */
    async init(initilizationData) {
        try {
            let _accountIndex, signerAddress;
            if (initilizationData) {
                _accountIndex = initilizationData.accountIndex;
                signerAddress = initilizationData.signerAddress;
            }
            if (!_accountIndex)
                _accountIndex = 0;
            this.isProviderDefined();
            this.isSignerDefined();
            if (signerAddress) {
                this.owner = signerAddress;
            }
            else {
                this.owner = await this.signer.getAddress();
            }
            this.chainId = await this.provider.getNetwork().then((net) => net.chainId);
            await this.initializeAccountAtIndex(_accountIndex);
            this._isInitialised = true;
        }
        catch (error) {
            common_1.Logger.error(`Failed to call init: ${error}`);
            throw error;
        }
        return this;
    }
    async attachSigner(_signer) {
        try {
            this.signer = _signer;
            this.owner = await this.signer.getAddress();
        }
        catch (error) {
            throw new Error(`Failed to get signer address`);
        }
    }
    isInitialized() {
        if (!this._isInitialised)
            throw new Error("BiconomySmartAccount is not initialized. Please call init() on BiconomySmartAccount instance before interacting with any other function");
        return true;
    }
    setProxyContractState() {
        if (!Constants_1.BICONOMY_IMPLEMENTATION_ADDRESSES[this.smartAccountInfo.implementationAddress])
            throw new Error("Could not find attached implementation address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
        const proxyInstanceDto = {
            smartAccountType: core_types_1.SmartAccountType.BICONOMY,
            version: Constants_1.BICONOMY_IMPLEMENTATION_ADDRESSES[this.smartAccountInfo.implementationAddress],
            contractAddress: this.address,
            provider: this.provider,
        };
        this.proxy = (0, common_1.getSAProxyContract)(proxyInstanceDto);
    }
    setEntryPointContractState() {
        const _entryPointAddress = this.smartAccountInfo.entryPointAddress;
        this.setEntryPointAddress(_entryPointAddress);
        if (!Constants_1.ENTRYPOINT_ADDRESSES[_entryPointAddress])
            throw new Error("Could not find attached entrypoint address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
        const entryPointInstanceDto = {
            smartAccountType: core_types_1.SmartAccountType.BICONOMY,
            version: Constants_1.ENTRYPOINT_ADDRESSES[_entryPointAddress],
            contractAddress: _entryPointAddress,
            provider: this.provider,
        };
        this.entryPoint = (0, common_1.getEntryPointContract)(entryPointInstanceDto);
    }
    setFactoryContractState() {
        const _factoryAddress = this.smartAccountInfo.factoryAddress;
        if (!Constants_1.BICONOMY_FACTORY_ADDRESSES[_factoryAddress])
            throw new Error("Could not find attached factory address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
        const factoryInstanceDto = {
            smartAccountType: core_types_1.SmartAccountType.BICONOMY,
            version: Constants_1.BICONOMY_FACTORY_ADDRESSES[_factoryAddress],
            contractAddress: _factoryAddress,
            provider: this.provider,
        };
        this.factory = (0, common_1.getSAFactoryContract)(factoryInstanceDto);
    }
    async setContractsState() {
        this.setProxyContractState();
        this.setEntryPointContractState();
        this.setFactoryContractState();
    }
    async initializeAccountAtIndex(accountIndex) {
        this.accountIndex = accountIndex;
        this.address = await this.getSmartAccountAddress(accountIndex);
        await this.setContractsState();
        await this.setInitCode(this.accountIndex);
    }
    async getSmartAccountAddress(accountIndex = 0) {
        try {
            this.isSignerDefined();
            let smartAccountsList = (await this.getSmartAccountsByOwner({
                chainId: this.chainId,
                owner: this.owner,
                index: accountIndex,
            })).data;
            if (!smartAccountsList)
                throw new Error("Failed to get smart account address. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
            smartAccountsList = smartAccountsList.filter((smartAccount) => {
                return accountIndex === smartAccount.index;
            });
            if (smartAccountsList.length === 0)
                throw new Error("Failed to get smart account address. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
            this.smartAccountInfo = smartAccountsList[0];
            return this.smartAccountInfo.smartAccountAddress;
        }
        catch (error) {
            common_1.Logger.error(`Failed to get smart account address: ${error}`);
            throw error;
        }
    }
    async setInitCode(accountIndex = 0) {
        this.initCode = ethers_1.ethers.utils.hexConcat([
            this.factory.address,
            this.factory.interface.encodeFunctionData("deployCounterFactualAccount", [this.owner, ethers_1.ethers.BigNumber.from(accountIndex)]),
        ]);
        return this.initCode;
    }
    /**
     * @description an overrided function to showcase overriding example
     * @returns
     */
    nonce() {
        this.isProxyDefined();
        return this.proxy.nonce();
    }
    /**
     *
     * @param to { target } address of transaction
     * @param value  represents amount of native tokens
     * @param data represent data associated with transaction
     * @returns
     */
    getExecuteCallData(to, value, data) {
        this.isInitialized();
        this.isProxyDefined();
        const executeCallData = this.proxy.interface.encodeFunctionData("executeCall", [to, value, data]);
        return executeCallData;
    }
    /**
     *
     * @param to { target } array of addresses in transaction
     * @param value  represents array of amount of native tokens associated with each transaction
     * @param data represent array of data associated with each transaction
     * @returns
     */
    getExecuteBatchCallData(to, value, data) {
        this.isInitialized();
        this.isProxyDefined();
        const executeBatchCallData = this.proxy.interface.encodeFunctionData("executeBatchCall", [to, value, data]);
        return executeBatchCallData;
    }
    getDummySignature() {
        return "0x73c3ac716c487ca34bb858247b5ccf1dc354fbaabdd089af3b2ac8e78ba85a4959a2d76250325bd67c11771c31fccda87c33ceec17cc0de912690521bb95ffcb1b";
    }
    getDummyPaymasterData() {
        return "0x";
    }
    async getNonce() {
        let nonce = ethers_1.BigNumber.from(0);
        try {
            nonce = await this.nonce();
        }
        catch (error) {
            // Not throwing this error as nonce would be 0 if this.nonce() throw exception, which is expected flow for undeployed account
            common_1.Logger.log("Error while getting nonce for the account. This is expected for undeployed accounts set nonce to 0");
        }
        return nonce;
    }
    async getGasFeeValues(overrides, skipBundlerGasEstimation) {
        const gasFeeValues = {
            maxFeePerGas: overrides === null || overrides === void 0 ? void 0 : overrides.maxFeePerGas,
            maxPriorityFeePerGas: overrides === null || overrides === void 0 ? void 0 : overrides.maxPriorityFeePerGas,
        };
        try {
            if (this.bundler && !gasFeeValues.maxFeePerGas && !gasFeeValues.maxPriorityFeePerGas && (skipBundlerGasEstimation !== null && skipBundlerGasEstimation !== void 0 ? skipBundlerGasEstimation : true)) {
                const gasFeeEstimation = await this.bundler.getGasFeeValues();
                gasFeeValues.maxFeePerGas = gasFeeEstimation.maxFeePerGas;
                gasFeeValues.maxPriorityFeePerGas = gasFeeEstimation.maxPriorityFeePerGas;
            }
            return gasFeeValues;
        }
        catch (error) {
            common_1.Logger.error("Error while getting gasFeeValues from bundler. Provided bundler might not have getGasFeeValues endpoint", error);
            return gasFeeValues;
        }
    }
    async buildUserOp(transactions, overrides, skipBundlerGasEstimation, paymasterServiceData) {
        var _a;
        this.isInitialized();
        const to = transactions.map((element) => element.to);
        const data = transactions.map((element) => { var _a; return (_a = element.data) !== null && _a !== void 0 ? _a : "0x"; });
        const value = transactions.map((element) => { var _a; return (_a = element.value) !== null && _a !== void 0 ? _a : ethers_1.BigNumber.from("0"); });
        this.isProxyDefined();
        const [nonce, gasFeeValues] = await Promise.all([this.getNonce(), this.getGasFeeValues(overrides, skipBundlerGasEstimation)]);
        let callData = "";
        if (transactions.length === 1) {
            callData = this.getExecuteCallData(to[0], value[0], data[0]);
        }
        else {
            callData = this.getExecuteBatchCallData(to, value, data);
        }
        let isDeployed = true;
        if (nonce.eq(0)) {
            isDeployed = await this.isAccountDeployed(this.address);
        }
        let userOp = {
            sender: this.address,
            nonce,
            initCode: !isDeployed ? this.initCode : "0x",
            callData: callData,
            maxFeePerGas: gasFeeValues.maxFeePerGas || undefined,
            maxPriorityFeePerGas: gasFeeValues.maxPriorityFeePerGas || undefined,
            signature: this.getDummySignature(),
        };
        // Note: Can change the default behaviour of calling estimations using bundler/local
        userOp = await this.estimateUserOpGas({ userOp, overrides, skipBundlerGasEstimation, paymasterServiceData });
        userOp.paymasterAndData = (_a = userOp.paymasterAndData) !== null && _a !== void 0 ? _a : "0x";
        common_1.Logger.log("UserOp after estimation ", userOp);
        return userOp;
    }
    validateUserOpAndRequest(userOp, tokenPaymasterRequest) {
        var _a;
        if (!userOp.callData) {
            throw new Error("Userop callData cannot be undefined");
        }
        const feeTokenAddress = (_a = tokenPaymasterRequest === null || tokenPaymasterRequest === void 0 ? void 0 : tokenPaymasterRequest.feeQuote) === null || _a === void 0 ? void 0 : _a.tokenAddress;
        common_1.Logger.log("requested fee token is ", feeTokenAddress);
        if (!feeTokenAddress || feeTokenAddress == ethers_1.ethers.constants.AddressZero) {
            throw new Error("Invalid or missing token address. Token address must be part of the feeQuote in tokenPaymasterRequest");
        }
        const spender = tokenPaymasterRequest === null || tokenPaymasterRequest === void 0 ? void 0 : tokenPaymasterRequest.spender;
        common_1.Logger.log("fee token approval to be checked and added for spender: ", spender);
        if (!spender || spender == ethers_1.ethers.constants.AddressZero) {
            throw new Error("Invalid or missing spender address. Sepnder address must be part of tokenPaymasterRequest");
        }
    }
    /**
     *
     * @param userOp partial user operation without signature and paymasterAndData
     * @param tokenPaymasterRequest This dto provides information about fee quote. Fee quote is received from earlier request getFeeQuotesOrData() to the Biconomy paymaster.
     *  maxFee and token decimals from the quote, along with the spender is required to append approval transaction.
     * @notice This method should be called when gas is paid in ERC20 token using TokenPaymaster
     * @description Optional method to update the userOp.calldata with batched transaction which approves the paymaster spender with necessary amount(if required)
     * @returns updated userOp with new callData, callGasLimit
     */
    async buildTokenPaymasterUserOp(userOp, tokenPaymasterRequest) {
        this.validateUserOpAndRequest(userOp, tokenPaymasterRequest);
        try {
            let batchTo = [];
            let batchValue = [];
            let batchData = [];
            let newCallData = userOp.callData;
            common_1.Logger.log("received information about fee token address and quote ", tokenPaymasterRequest);
            if (this.paymaster && this.paymaster instanceof paymaster_1.BiconomyPaymaster) {
                // Make a call to paymaster.buildTokenApprovalTransaction() with necessary details
                // Review: might request this form of an array of Transaction
                const approvalRequest = await this.paymaster.buildTokenApprovalTransaction(tokenPaymasterRequest, this.provider);
                common_1.Logger.log("approvalRequest is for erc20 token ", approvalRequest.to);
                if (approvalRequest.data == "0x" || approvalRequest.to == ethers_1.ethers.constants.AddressZero) {
                    return userOp;
                }
                if (!userOp.callData) {
                    throw new Error("Userop callData cannot be undefined");
                }
                const decodedDataSmartWallet = this.proxy.interface.parseTransaction({
                    data: userOp.callData.toString(),
                });
                if (!decodedDataSmartWallet) {
                    throw new Error("Could not parse call data of smart wallet for userOp");
                }
                const smartWalletExecFunctionName = decodedDataSmartWallet.name;
                if (smartWalletExecFunctionName === "executeCall") {
                    common_1.Logger.log("originally an executeCall for Biconomy Account");
                    const methodArgsSmartWalletExecuteCall = decodedDataSmartWallet.args;
                    const toOriginal = methodArgsSmartWalletExecuteCall[0];
                    const valueOriginal = methodArgsSmartWalletExecuteCall[1];
                    const dataOriginal = methodArgsSmartWalletExecuteCall[2];
                    batchTo.push(toOriginal);
                    batchValue.push(valueOriginal);
                    batchData.push(dataOriginal);
                }
                else if (smartWalletExecFunctionName === "executeBatchCall") {
                    common_1.Logger.log("originally an executeBatchCall for Biconomy Account");
                    const methodArgsSmartWalletExecuteCall = decodedDataSmartWallet.args;
                    batchTo = methodArgsSmartWalletExecuteCall[0];
                    batchValue = methodArgsSmartWalletExecuteCall[1];
                    batchData = methodArgsSmartWalletExecuteCall[2];
                }
                if (approvalRequest.to && approvalRequest.data && approvalRequest.value) {
                    batchTo = [approvalRequest.to, ...batchTo];
                    batchValue = [approvalRequest.value, ...batchValue];
                    batchData = [approvalRequest.data, ...batchData];
                    newCallData = this.getExecuteBatchCallData(batchTo, batchValue, batchData);
                }
                const finalUserOp = {
                    ...userOp,
                    callData: newCallData,
                };
                return finalUserOp;
            }
        }
        catch (error) {
            common_1.Logger.log("Failed to update userOp. sending back original op");
            common_1.Logger.error("Failed to update callData with error", error);
            return userOp;
        }
        return userOp;
    }
    async getAllTokenBalances(balancesDto) {
        return this.nodeClient.getAllTokenBalances(balancesDto);
    }
    async getTotalBalanceInUsd(balancesDto) {
        return this.nodeClient.getTotalBalanceInUsd(balancesDto);
    }
    async getSmartAccountsByOwner(smartAccountByOwnerDto) {
        return this.nodeClient.getSmartAccountsByOwner(smartAccountByOwnerDto);
    }
    async getTransactionsByAddress(chainId, address) {
        return this.nodeClient.getTransactionByAddress(chainId, address);
    }
    async getTransactionByHash(txHash) {
        return this.nodeClient.getTransactionByHash(txHash);
    }
    async getAllSupportedChains() {
        return this.nodeClient.getAllSupportedChains();
    }
    async getUpdateImplementationData(newImplementationAddress) {
        // V2 address or latest implementation if possible to jump from V1 -> Vn without upgrading to V2
        // If needed we can fetch this from backend config
        common_1.Logger.log("Recommended implementation address to upgrade to", Constants_1.BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION.V2_0_0);
        const latestImplementationAddress = newImplementationAddress !== null && newImplementationAddress !== void 0 ? newImplementationAddress : Constants_1.DEFAULT_BICONOMY_IMPLEMENTATION_ADDRESS; // BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION.V2_0_0 // 2.0
        common_1.Logger.log("Requested implementation address to upgrade to", latestImplementationAddress);
        // by querying the proxy contract
        // TODO: add isDeployed checks before reading below
        const currentImplementationAddress = await this.proxy.getImplementation();
        common_1.Logger.log("Current implementation address for this Smart Account", currentImplementationAddress);
        if (ethers_1.ethers.utils.getAddress(currentImplementationAddress) !== ethers_1.ethers.utils.getAddress(latestImplementationAddress)) {
            const impInterface = new ethers_1.ethers.utils.Interface(["function updateImplementation(address _implementation)"]);
            const encodedData = impInterface.encodeFunctionData("updateImplementation", [latestImplementationAddress]);
            return { to: this.address, value: ethers_1.BigNumber.from(0), data: encodedData };
        }
        else {
            return { to: this.address, value: 0, data: "0x" };
        }
    }
    async getModuleSetupData(ecdsaModuleAddress) {
        try {
            const moduleAddress = ecdsaModuleAddress !== null && ecdsaModuleAddress !== void 0 ? ecdsaModuleAddress : modules_1.DEFAULT_ECDSA_OWNERSHIP_MODULE;
            const ecdsaModule = await modules_1.ECDSAOwnershipValidationModule.create({
                signer: this.signer,
                moduleAddress: moduleAddress,
            });
            // initForSmartAccount
            const ecdsaOwnershipSetupData = await ecdsaModule.getInitData();
            const proxyInstanceDto = {
                smartAccountType: core_types_1.SmartAccountType.BICONOMY,
                version: "V2_0_0",
                contractAddress: this.address,
                provider: this.provider,
            };
            const accountV2 = (0, common_1.getSAProxyContract)(proxyInstanceDto);
            const data = accountV2.interface.encodeFunctionData("setupAndEnableModule", [moduleAddress, ecdsaOwnershipSetupData]);
            return { to: this.address, value: 0, data: data };
        }
        catch (error) {
            common_1.Logger.error("Failed to get module setup data", error);
            // Could throw error
            return { to: this.address, value: 0, data: "0x" };
        }
    }
    // Once this userOp is sent (batch: a. updateImplementation and b. setupModule on upgraded proxy)
    // Afterwards you can start using BiconomySmartAccountV2
    async updateImplementationUserOp(newImplementationAddress, ecdsaModuleAddress) {
        const tx1 = await this.getUpdateImplementationData(newImplementationAddress);
        const tx2 = await this.getModuleSetupData(ecdsaModuleAddress);
        if (tx1.data !== "0x" && tx2.data !== "0x") {
            const partialUserOp = await this.buildUserOp([tx1, tx2]);
            return partialUserOp;
        }
        else {
            throw new Error("Not eligible for upgrade");
        }
    }
}
exports.BiconomySmartAccount = BiconomySmartAccount;
//# sourceMappingURL=BiconomySmartAccount.js.map